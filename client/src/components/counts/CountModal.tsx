import { useState, useEffect } from "react";
import { useQueryClient, useMutation, useQuery } from "@tanstack/react-query";
import { useForm } from "react-hook-form";
import { z } from "zod";
import { format } from "date-fns";
import { zodResolver } from "@hookform/resolvers/zod";
import { apiRequest } from "@/lib/queryClient";
import { Loader2, Trash2, AlertTriangle } from "lucide-react";
import { useToast } from "@/hooks/use-toast";
import { insertBatchSchema, Batch, ServiceOption } from "@shared/schema";
import { useLocation } from "wouter";
import ConfirmDialog from "@/components/ui/confirm-dialog";
import { useAuth } from "@/hooks/useAuth";

import {
  Dialog,
  DialogContent,
  DialogHeader,
  DialogTitle,
  DialogFooter,
  DialogDescription,
} from "@/components/ui/dialog";
import {
  Form,
  FormControl,
  FormField,
  FormItem,
  FormLabel,
  FormDescription,
  FormMessage,
} from "@/components/ui/form";
import { Input } from "@/components/ui/input";
import { 
  Select, 
  SelectContent, 
  SelectItem, 
  SelectTrigger, 
  SelectValue 
} from "@/components/ui/select";
import { Textarea } from "@/components/ui/textarea";
import { Button } from "@/components/ui/button";

// Form schema for validation
const formSchema = insertBatchSchema.extend({
  date: z.string().min(1, "Date is required"),
  service: z.string().optional(),
});

// Infer the type from the schema
type FormValues = z.infer<typeof formSchema>;

interface CountModalProps {
  isOpen: boolean;
  onClose: () => void;
  batchId: number | null;
  isEdit?: boolean;
}

const CountModal = ({ isOpen, onClose, batchId, isEdit = false }: CountModalProps) => {
  const { toast } = useToast();
  const queryClient = useQueryClient();
  const [_, setLocation] = useLocation();
  const { isAdmin } = useAuth();
  const [showDeleteConfirm, setShowDeleteConfirm] = useState(false);
  const [showFinalizedDeleteConfirm, setShowFinalizedDeleteConfirm] = useState(false);
  
  // Fetch service options from the API
  const { data: serviceOptions = [], isLoading: isLoadingServiceOptions } = useQuery<ServiceOption[]>({
    queryKey: ['/api/service-options'],
    queryFn: async () => {
      const response = await fetch('/api/service-options');
      if (!response.ok) {
        throw new Error("Failed to fetch service options");
      }
      return response.json();
    },
  });
  
  // Find the default service option when service options are loaded
  // Create a default option if no service options exist to prevent app crashes
  const defaultServiceOption = 
    serviceOptions.find(option => option.isDefault) ||
    (serviceOptions.length > 0 ? serviceOptions[0] : {
      id: -1,
      name: "Default Service",
      isDefault: true,
      createdAt: new Date().toISOString(),
      updatedAt: new Date().toISOString(),
      churchId: ''
    });
  
  // Initialize the form
  const form = useForm<FormValues>({
    resolver: zodResolver(formSchema),
    defaultValues: {
      // Use current date but format it manually to avoid timezone issues
      date: (() => {
        const now = new Date();
        const year = now.getFullYear();
        const month = String(now.getMonth() + 1).padStart(2, '0'); // getMonth() is 0-based
        const day = String(now.getDate()).padStart(2, '0');
        return `${year}-${month}-${day}`;
      })(),
      // Let the name be generated by the useEffect that watches date and service
      name: "", 
      status: "OPEN",
      notes: "",
      service: "", // Will be updated after service options load
    },
  });
  
  // Fetch batch details if editing
  const { data: batchData, isLoading: isLoadingBatch } = useQuery<Batch>({
    queryKey: ['/api/batches', batchId],
    queryFn: async () => {
      if (!batchId) return null;
      
      const response = await fetch(`/api/batches/${batchId}`);
      if (!response.ok) {
        throw new Error("Failed to fetch count");
      }
      
      return response.json();
    },
    enabled: !!batchId && isEdit,
  });
  
  // Set form values when batch data is loaded
  useEffect(() => {
    if (batchData) {
      // Try to format the date directly from the batch date
      let formattedDate = "";
      try {
        // First try to parse directly from date field string representation
        const rawDate = batchData.date ? String(batchData.date) : "";

        // If a direct date field is available, use ISO string
        if (rawDate.includes("-")) {
          // Already in ISO format
          formattedDate = rawDate.split("T")[0]; // Extract YYYY-MM-DD part
        } else {
          // Try to parse from batch name (e.g., "Morning Service, May 4, 2025")
          const nameParts = batchData.name.split(",");
          if (nameParts.length >= 3) {
            // Extract the date part (e.g. "May 4, 2025")
            const datePart = nameParts.slice(1).join(",").trim();
            
            // Try to match "Month Day, Year" pattern
            const dateMatch = datePart.match(/([A-Za-z]+)\s+(\d+),\s+(\d{4})/);
            if (dateMatch) {
              const [, month, day, year] = dateMatch;
              
              // Convert month name to month number (1-12)
              const monthNames = [
                "January", "February", "March", "April", "May", "June",
                "July", "August", "September", "October", "November", "December"
              ];
              
              const monthIndex = monthNames.findIndex(m => 
                month.toLowerCase() === m.toLowerCase() || 
                (month.length >= 3 && m.toLowerCase().startsWith(month.toLowerCase()))
              );
              
              if (monthIndex !== -1) {
                // Format as YYYY-MM-DD for date input
                const monthNum = monthIndex + 1;
                formattedDate = `${year}-${String(monthNum).padStart(2, '0')}-${String(day).padStart(2, '0')}`;
              }
            }
          }
        }
      } catch (error) {
        console.error("Error parsing batch date for edit form:", error);
        // Fallback to today's date if all else fails
        formattedDate = format(new Date(), 'yyyy-MM-dd');
      }
      
      console.log("Setting edit form date:", formattedDate, "Original batch date:", batchData.date);
      
      form.reset({
        name: batchData.name,
        date: formattedDate,
        status: batchData.status,
        notes: batchData.notes ?? "",
        service: batchData.service ?? "",
      });
    }
  }, [batchData, form]);
  
  // Set default service option when options are loaded
  useEffect(() => {
    // Only set default for new counts (not when editing)
    if (!isEdit && defaultServiceOption) {
      // Convert ID to string for select value
      const defaultValue = String(defaultServiceOption.id);
      
      // Always set the service value when defaultServiceOption is available
      // This ensures it's set on initial load
      form.setValue('service', defaultValue);
      
      // Force a re-render of the component to ensure the select shows the value
      setTimeout(() => {
        const currentValue = form.getValues('service');
        if (currentValue !== defaultValue) {
          form.setValue('service', defaultValue, { shouldDirty: true });
        }
      }, 0);
    }
  }, [serviceOptions, defaultServiceOption, isEdit, form]);
  
  // Auto-generate name when date or service changes
  useEffect(() => {
    const date = form.watch('date');
    const service = form.watch('service');
    
    if (date) {
      // Parse the date string (format: 'yyyy-MM-dd') manually to avoid timezone issues
      try {
        // Split into year, month, day
        const [year, month, day] = date.split('-').map(part => parseInt(part, 10));
        
        // Get month name - months are 0-indexed in JS
        const monthNames = [
          "January", "February", "March", "April", "May", "June",
          "July", "August", "September", "October", "November", "December"
        ];
        
        // Safely check if we have valid values
        if (year && month && day && month >= 1 && month <= 12) {
          // Format: "Month Day, Year" without using Date object
          const formattedDate = `${monthNames[month-1]} ${day}, ${year}`;
          let nameValue = formattedDate;
          
          // Find the service option by value
          if (service && serviceOptions.length > 0) {
            const serviceOption = serviceOptions.find(option => option.value === service);
            if (serviceOption) {
              nameValue = `${serviceOption.name}, ${formattedDate}`;
            }
          }
          
          console.log("Setting batch name to:", nameValue, "from date:", date);
          form.setValue('name', nameValue);
        }
      } catch (error) {
        console.error("Error formatting date for batch name:", error);
      }
    }
  }, [form.watch('date'), form.watch('service'), serviceOptions, form]);
  
  // Create/update batch mutation
  const createBatchMutation = useMutation({
    mutationFn: async (values: FormValues) => {
      const url = isEdit && batchId ? `/api/batches/${batchId}` : '/api/batches';
      const method = isEdit ? "PATCH" : "POST";
      
      const response = await fetch(url, {
        method,
        headers: {
          'Content-Type': 'application/json',
        },
        body: JSON.stringify(values)
      });
      
      if (!response.ok) {
        const error = await response.json();
        throw new Error(error.message || "Failed to save count");
      }
      
      return response.json();
    },
    onSuccess: (data) => {
      // Invalidate all relevant queries to ensure complete UI refresh
      queryClient.invalidateQueries({ queryKey: ['/api/batches'] });
      queryClient.invalidateQueries({ queryKey: ['/api/batches/current'] });
      queryClient.invalidateQueries({ queryKey: ['/api/dashboard/stats'] });
      
      // Also invalidate these queries to ensure dashboard data refreshes
      queryClient.invalidateQueries({ queryKey: ['/api/batches/latest-finalized'] });
      queryClient.invalidateQueries({ queryKey: ['/api/stats'] });
      queryClient.invalidateQueries({ queryKey: ['/api/dashboard'] });
      
      // Toast removed for better user experience
      
      onClose();
      
      // Use setTimeout to ensure UI has time to update before navigation
      setTimeout(() => {
        // For new count creation, redirect to the batch detail page
        if (!isEdit && data && data.id) {
          console.log(`Navigating to batch/${data.id}`);
          setLocation(`/batch/${data.id}`);
        } else if (isEdit && batchId) {
          // For edits, redirect to the batch detail page if we're not already there
          console.log(`Navigating to batch/${batchId}`);
          setLocation(`/batch/${batchId}`);
        }
      }, 300);
    },
    onError: (error) => {
      toast({
        title: "Error",
        description: `Failed to ${isEdit ? 'update' : 'create'} count: ${error instanceof Error ? error.message : 'Unknown error'}`,
        variant: "destructive",
      });
    },
  });
  
  // Delete batch mutation
  const deleteBatchMutation = useMutation<void, Error, void>({
    mutationFn: async () => {
      if (!batchId) return;
      
      const response = await fetch(`/api/batches/${batchId}`, {
        method: 'DELETE',
      });
      
      if (!response.ok) {
        throw new Error("Failed to delete count");
      }
    },
    onSuccess: () => {
      queryClient.invalidateQueries({ queryKey: ['/api/batches'] });
      queryClient.invalidateQueries({ queryKey: ['/api/batches/current'] });
      queryClient.invalidateQueries({ queryKey: ['/api/dashboard/stats'] });
      
      toast({
        title: "Count Deleted",
        description: "The count and all associated donations have been deleted successfully.",
        className: "bg-[#48BB78] text-white",
      });
      
      onClose();
      setLocation('/counts');
    },
    onError: (error) => {
      toast({
        title: "Error",
        description: `Failed to delete count: ${error instanceof Error ? error.message : 'Unknown error'}`,
        variant: "destructive",
      });
    }
  });
  
  // Form submission handler
  const onSubmit = (values: FormValues) => {
    // If the service is the default fallback service (-1), make sure it gets processed correctly
    if (values.service === "-1") {
      console.log("Using default service option for submission");
      // Making a copy to avoid directly modifying the form values
      const submissionValues = {
        ...values,
        // We flag this as a default service so the backend knows to handle it appropriately
        useDefaultService: true
      };
      createBatchMutation.mutate(submissionValues);
    } else {
      createBatchMutation.mutate(values);
    }
  };
  
  return (
    <>
      <Dialog open={isOpen} onOpenChange={(open) => !open && onClose()}>
        <DialogContent className="sm:max-w-[500px] bg-white">
          <DialogHeader>
            <DialogTitle className="text-xl font-bold text-[#2D3748]">
              {isEdit ? "Edit Count" : "Create New Count"}
            </DialogTitle>
          </DialogHeader>
          
          {isLoadingBatch ? (
            <div className="flex justify-center items-center py-8">
              <Loader2 className="h-8 w-8 animate-spin text-[#4299E1]" />
            </div>
          ) : (
            <Form {...form}>
              <form onSubmit={form.handleSubmit(onSubmit)} className="space-y-6 pt-4">
                <FormField
                  control={form.control}
                  name="date"
                  render={({ field }) => (
                    <FormItem>
                      <FormLabel className="font-bold">Date:</FormLabel>
                      <FormControl>
                        <Input 
                          {...field} 
                          type="date" 
                          className="text-left w-full" 
                        />
                      </FormControl>

                      <FormMessage />
                    </FormItem>
                  )}
                />
                
                <FormField
                  control={form.control}
                  name="service"
                  render={({ field }) => (
                    <FormItem>
                      <FormLabel className="font-bold">Service:</FormLabel>
                      <Select
                        value={field.value}
                        onValueChange={field.onChange}
                      >
                        <FormControl>
                          <SelectTrigger>
                            <SelectValue placeholder="Select a service" />
                          </SelectTrigger>
                        </FormControl>
                        <SelectContent>
                          {/* Only configured service options */}
                          {isLoadingServiceOptions ? (
                            <SelectItem value="loading" disabled>Loading options...</SelectItem>
                          ) : Array.isArray(serviceOptions) && serviceOptions.length > 0 ? (
                            // Sort service options to put default option first
                            [...serviceOptions]
                              .sort((a, b) => {
                                // Put default option first
                                if (a.isDefault) return -1;
                                if (b.isDefault) return 1;
                                // Otherwise sort alphabetically
                                return a.name.localeCompare(b.name);
                              })
                              .map((option) => (
                                <SelectItem key={option.id} value={String(option.id)}>
                                  {option.name}
                                </SelectItem>
                              ))
                          ) : (
                            // If no service options are defined, use the default one we created
                            <SelectItem value="-1">Default Service</SelectItem>
                          )}
                        </SelectContent>
                      </Select>

                      <FormMessage />
                    </FormItem>
                  )}
                />
                
                {/* 
                  Status field - hidden in Create mode, only shown in Edit mode
                  For new counts, status is always set to OPEN in the form values
                */}
                {isEdit ? (
                  <FormField
                    control={form.control}
                    name="status"
                    render={({ field }) => (
                      <FormItem>
                        <FormLabel className="font-bold">Status:</FormLabel>
                        <Select
                          value={field.value}
                          onValueChange={field.onChange}
                        >
                          <FormControl>
                            <SelectTrigger>
                              <SelectValue />
                            </SelectTrigger>
                          </FormControl>
                          <SelectContent>
                            <SelectItem value="OPEN">Open</SelectItem>
                            <SelectItem value="FINALIZED">Finalized</SelectItem>
                          </SelectContent>
                        </Select>
                        <FormMessage />
                      </FormItem>
                    )}
                  />
                ) : (
                  <input type="hidden" name="status" value="OPEN" />
                )}
                
                <FormField
                  control={form.control}
                  name="notes"
                  render={({ field }) => (
                    <FormItem>
                      <FormLabel className="font-bold">Notes (Optional):</FormLabel>
                      <FormControl>
                        <Textarea 
                          rows={3} 
                          onChange={field.onChange}
                          onBlur={field.onBlur}
                          value={field.value || ""}
                          disabled={field.disabled}
                          name={field.name}
                          ref={field.ref}
                        />
                      </FormControl>

                      <FormMessage />
                    </FormItem>
                  )}
                />
                
                <DialogFooter className="flex sm:flex">
                  {isEdit && (
                    // Only show delete button if it's an OPEN batch or user is ADMIN
                    (!batchData || batchData.status === "OPEN" || isAdmin) && (
                      <Button
                        type="button"
                        variant="outline"
                        className="border-red-500 text-red-600 hover:bg-red-50 mr-auto"
                        onClick={() => {
                          // For FINALIZED batches, if user is ADMIN, show special warning
                          if (batchData && batchData.status === "FINALIZED" && isAdmin) {
                            setShowFinalizedDeleteConfirm(true);
                          } else {
                            setShowDeleteConfirm(true);
                          }
                        }}
                      >
                        <Trash2 className="mr-2 h-4 w-4" />
                        Delete Count
                      </Button>
                    )
                  )}
                  <div className="flex gap-2 ml-auto">
                    <Button
                      type="button"
                      variant="outline"
                      onClick={onClose}
                    >
                      Cancel
                    </Button>
                    <Button 
                      type="submit" 
                      className="bg-[#69ad4c] hover:bg-[#5c9a42] text-white"
                      disabled={createBatchMutation.isPending}
                    >
                      {createBatchMutation.isPending && (
                        <Loader2 className="mr-2 h-4 w-4 animate-spin" />
                      )}
                      {isEdit ? "Update Count" : "Create Count"}
                    </Button>
                  </div>
                </DialogFooter>
              </form>
            </Form>
          )}
        </DialogContent>
      </Dialog>
      
      {/* Regular delete confirmation dialog for OPEN counts */}
      <ConfirmDialog
        isOpen={showDeleteConfirm}
        onClose={() => setShowDeleteConfirm(false)}
        onConfirm={() => deleteBatchMutation.mutate()}
        title="Delete Count"
        description="Are you sure you want to delete this count? This action cannot be undone and will permanently delete the count and all associated donations."
        confirmText="Delete Count"
        cancelText="Cancel"
        isPending={deleteBatchMutation.isPending}
        destructive={true}
      />
      
      {/* Special warning dialog for FINALIZED counts (Admin only) */}
      <ConfirmDialog
        isOpen={showFinalizedDeleteConfirm}
        onClose={() => setShowFinalizedDeleteConfirm(false)}
        onConfirm={() => deleteBatchMutation.mutate()}
        title="Delete Finalized Count - Warning!"
        description={
          <div className="space-y-3">
            <div className="flex items-start">
              <AlertTriangle className="h-5 w-5 text-amber-500 mr-2 mt-0.5 flex-shrink-0" />
              <p className="text-amber-700">
                You are about to delete a FINALIZED count. This is irreversible and will permanently delete all associated financial records.
              </p>
            </div>
            <p className="font-semibold text-destructive">
              This action cannot be undone and may impact your financial records!
            </p>
          </div>
        }
        confirmText="Yes, Delete Finalized Count"
        cancelText="Cancel"
        isPending={deleteBatchMutation.isPending}
        destructive={true}
      />
    </>
  );
};

export default CountModal;